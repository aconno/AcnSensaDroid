<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="../html_resources/Rubik.css" rel="stylesheet">
    <link rel="stylesheet" href="../html_resources/materialize_min_new.css">
    <style type="text/css">
    body {
        font-family: 'Rubik', sans-serif;
    }
    </style>
    <link rel="stylesheet" href="../html_resources/newStyles.css">
    <link rel="stylesheet" href="../html_resources/webCounterStyles.css">
    <script src="../html_resources/counter.js" type="text/javascript"></script>
</head>

<body style="background-color:#fafafa">
    <div class="acnact">
        <p>
            <span style="display: block;" class="acnact-value">Count: </span>
            <div id="odometer" style="font-size: 50px" class="odometer">000</div>
    </div>
    <div class="acnact-btn-div">
        <input type="button" id="btn" class="acnact-btn" value="">
    </div>
    <script>
    var counter = 0;
    var deviceCounter = 0;
    var readingState = -2;
    var buttonCounter = 0;
    var latestAdvId = -1234;
    var BUTTON_PRESSED = 1;
    var BUTTON_NOT_PRESSED = 0;

    window.odometerOptions = {
        auto: true, // Don't automatically initialize everything with class 'odometer'
        selector: '.my-numbers', // Change the selector used to automatically find things to be animated
        format: 'd', // Change how digit groups are formatted, and how many digits are shown after the decimal point
        duration: 500, // Change how long the javascript expects the CSS animation to take
        theme: 'car', // Specify the theme (if you have more than one theme css file on the page)
        animation: 'count' // Count is a simpler animation method which just increments the value,
        // use it when you're looking for something more subtle.
    };

    startCounter();

    function onSensorReadings(json_values) {
        console.log(json_values);
        var readingState = null;
        var readingCounter = null;

        JSON.parse(json_values, function(key, value) {
            if (key == "BtnState") {
                readingState = parseInt(value);
            }
            if (key == "TmpCounter") {
                onCountUpdated(value);
            }

        });

        if (readingState != null && readingCounter != null) {
            if (latestAdvId != readingCounter && readingState == BUTTON_PRESSED) {
                latestAdvId = readingCounter
                document.getElementById("btn").style.backgroundColor = "rgb(211,211,211)";
            } else if (latestAdvId == readingCounter && readingState == BUTTON_NOT_PRESSED) {
                document.getElementById("btn").style.backgroundColor = "rgb(253,155,39)";
            } else {}
        }

    }

    function onSensorReading(name, value) {

        if (name == "TmpCounter") {
            if (latestAdvId != value) {
                latestAdvId = value;
                onCountUpdated(value);
                //document.getElementById("count").innerHTML = ++readingCounter;
                document.getElementById("btn").style.backgroundColor = "rgb(211,211,211)";
            } else {
                document.getElementById("btn").style.backgroundColor = "rgb(253,155,39)";
            }
        }

    }

    function setCount(value) {
        console.log(value);
        odometer.innerHTML = value;
    }

    function onCountUpdated(value) {
        readingCounter = parseInt(value);
        if (readingCounter > deviceCounter) {
            deviceCounter = readingCounter;
        } else {
            setCount(readingCounter);
        }
    }

    function sleep(milliseconds) {
        return new Promise(resolve => setTimeout(resolve, milliseconds));
    }

    async function startCounter() {
        if (counter < deviceCounter) {
            counter++;
            setCount(counter);
        }
        await sleep(400);
        setCounter();
    }
    </script>
</body>

</html>